void moveSphere(out vec4 spherePos, in float time) {
    if (time < 20.0) {
    	spherePos.y += (3.0 * abs(sin(time * time))) / (time * time + 0.00001);
    }
    spherePos.x += time * 0.5;
}

color4 calcColor(in sViewport vp, in sRay ray, in float time)
{
    sSphere sphere;
    // out sSphere s, in sPoint pos, in sScalar size, in color4 color, in color4 lightColor
    float ratio = vp.resolution.x * vp.resolutionInv.y;
    initSphere(sphere, vec4(-ratio - 0.3, -0.7, -3.0, 0.0), 0.3, vec4(1.0, 0.0, 0.0, 1.0), vec4(1.0));
    
    moveSphere(sphere.pos, time);
    
    sLight lights[1];
    // out sLight l, in sPoint pos, in sScalar intensity, in color4 color
    initLight(lights[0], vec4(0.0, 0.0, 0.0, 0.0), 100.0, vec4(1.0, 1.0, 1.0, 1.0));
    
    vec3 dp;
    dp.xy = ray.direction.xy - sphere.pos.xy;
    float lSq = lengthSq(dp.xy);
    float rSq = sphere.size * sphere.size;
    if (lSq <= rSq) {
        dp.z = rSq - lSq;
        vec3 position = sphere.pos.xyz + vec3(dp.x, dp.y, sqrt(dp.z));
        vec3 normal = (position - sphere.pos.xyz) / sphere.size;
        
        //return sphere normal;
        color4 sphereColor = vec4(normal * 0.5 + 0.5, 1.0);
        
        // Lighting
    	vec3 specularColor = vec3(1.0, 1.0, 1.0);
        float globalAmbientIntensity = 0.05;
        vec3 globalAmbientColor = vec3(1.0, 1.0, 1.0);
        
        // Calculates the sum of the effect of all lights on the sphere
        vec3 lightingInstensitySum = vec3(0.0, 0.0, 0.0);
        for (int i = lights.length() - 1; i >= 0; --i) {
            float lightDiffuseCoef, lightAttenuation;
            
            vec3 LightVector = lights[i].pos.xyz - position;
            float d = sqrt(lengthSq(LightVector));
            
            lightDiffuseCoef = diffuseCoef(normal, sphere.pos.xyz, lights[0].pos.xyz);
            lightAttenuation = attinuation(lights[i].intensity, d);
            lightingInstensitySum += finalColor(lightDiffuseCoef, lightAttenuation, sphere.color.xyz, lights[i].color.xyz);            
        }
        
        // Final Color
        vec3 finalColor = (globalAmbientIntensity * globalAmbientColor) + lightingInstensitySum;
        return vec4(finalColor, 1.0);
    }
    return vec4(0.0, 1.0, 1.0, 1.0);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
	// viewing plane (viewport) inputs
    const sBasis eyePosition = sBasis(0.0);
    const sScalar viewportHeight = 2.0, focalLength = 1.5;
    
    // viewport info
    sViewport vp;

    // ray
    sRay ray;
    
    // render
    initViewport(vp, viewportHeight, focalLength, fragCoord, iResolution.xy);
    initRayPersp(ray, eyePosition, vp.viewportPoint.xyz);
    fragColor += calcColor(vp, ray, iTime);
}